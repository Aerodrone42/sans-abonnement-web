
import { useState, useRef, useEffect } from 'react';
import { EnhancedChatGPTService } from '@/services/enhancedChatGptService';
import { SpeechSynthesisService } from '@/services/speechSynthesisService';

interface UseVoiceRecognitionProps {
  onTranscript: (text: string, field: string) => void;
  conversationMode: boolean;
  chatGPT: EnhancedChatGPTService | null;
}

export const useVoiceRecognition = ({ onTranscript, conversationMode, chatGPT }: UseVoiceRecognitionProps) => {
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState("");
  const [isProcessing, setIsProcessing] = useState(false);
  const [lastResponse, setLastResponse] = useState("");
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isConversationActive, setIsConversationActive] = useState(false);
  
  const recognitionRef = useRef<SpeechRecognition | null>(null);
  const mediaStreamRef = useRef<MediaStream | null>(null);
  const speechSynthesis = useRef(new SpeechSynthesisService()).current;
  const responseTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isStoppedRef = useRef(false);
  const restartTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const cleanupMicrophone = () => {
    console.log('üßπ Nettoyage complet du microphone...');
    setIsListening(false);
    setIsConversationActive(false);
    
    if (responseTimeoutRef.current) {
      clearTimeout(responseTimeoutRef.current);
      responseTimeoutRef.current = null;
    }

    if (restartTimeoutRef.current) {
      clearTimeout(restartTimeoutRef.current);
      restartTimeoutRef.current = null;
    }
    
    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach(track => {
        console.log('üõë Arr√™t track:', track.kind);
        track.stop();
      });
      mediaStreamRef.current = null;
    }

    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch (error) {
        console.log('Recognition d√©j√† arr√™t√©e');
      }
    }
  };

  const stopSpeaking = () => {
    console.log('üõë ARR√äT TOTAL - stopSpeaking appel√©');
    
    isStoppedRef.current = true;
    setIsConversationActive(false);
    speechSynthesis.stop();
    setIsSpeaking(false);
    setIsProcessing(false);
    
    if (restartTimeoutRef.current) {
      clearTimeout(restartTimeoutRef.current);
      restartTimeoutRef.current = null;
    }
    
    console.log('‚úÖ IA compl√®tement arr√™t√©e');
  };

  const restartListening = async () => {
    if (isStoppedRef.current || !isConversationActive) {
      console.log('‚ùå Conversation arr√™t√©e, pas de red√©marrage');
      return;
    }

    try {
      console.log('üîÑ Red√©marrage de l\'√©coute...');
      
      if (!mediaStreamRef.current) {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaStreamRef.current = stream;
      }

      if (recognitionRef.current && !isListening) {
        recognitionRef.current.start();
        setIsListening(true);
        console.log('üé§ √âcoute red√©marr√©e avec succ√®s');
      }
    } catch (error) {
      console.error('‚ùå Erreur red√©marrage √©coute:', error);
      // Retry apr√®s d√©lai si erreur
      if (isConversationActive && !isStoppedRef.current) {
        restartTimeoutRef.current = setTimeout(() => {
          if (isConversationActive && !isStoppedRef.current) {
            restartListening();
          }
        }, 1000);
      }
    }
  };

  const processAIResponse = async (finalTranscript: string) => {
    if (!conversationMode || !chatGPT) {
      onTranscript(finalTranscript, "message");
      return;
    }

    console.log('ü§ñ Traitement r√©ponse IA - isStoppedRef:', isStoppedRef.current);
    
    if (isStoppedRef.current) {
      console.log('‚ùå Traitement annul√© - conversation arr√™t√©e');
      return;
    }

    setIsProcessing(true);
    
    // Arr√™ter l'√©coute pendant le traitement
    if (recognitionRef.current && isListening) {
      try {
        recognitionRef.current.stop();
        setIsListening(false);
      } catch (error) {
        console.log('Recognition d√©j√† arr√™t√©e');
      }
    }

    try {
      console.log('üì§ Envoi message √† l\'IA:', finalTranscript);
      const response = await chatGPT.sendMessage(finalTranscript);
      
      console.log('üì• R√©ponse IA re√ßue:', response.substring(0, 50) + '...');
      
      if (isStoppedRef.current) {
        console.log('‚ùå Conversation arr√™t√©e pendant traitement');
        setIsProcessing(false);
        return;
      }
      
      setLastResponse(response);
      setIsSpeaking(true);
      setIsProcessing(false);
      
      // Parler et programmer le red√©marrage automatique
      speechSynthesis.speak(response, () => {
        console.log('üéØ Fin de la synth√®se vocale - red√©marrage programm√©');
        setIsSpeaking(false);
        
        // Red√©marrage automatique apr√®s un d√©lai
        if (conversationMode && !isStoppedRef.current && isConversationActive) {
          console.log('‚è∞ Programmation red√©marrage dans 2 secondes...');
          restartTimeoutRef.current = setTimeout(() => {
            if (!isStoppedRef.current && isConversationActive && !isListening) {
              console.log('üîÑ Ex√©cution du red√©marrage automatique');
              restartListening();
            }
          }, 2000);
        }
      });
    } catch (error) {
      console.error('‚ùå Erreur traitement IA:', error);
      setIsProcessing(false);
      setIsSpeaking(false);
      
      // Red√©marrer m√™me en cas d'erreur
      if (conversationMode && !isStoppedRef.current && isConversationActive) {
        restartTimeoutRef.current = setTimeout(() => {
          if (!isStoppedRef.current && isConversationActive) {
            restartListening();
          }
        }, 2000);
      }
    }
  };

  const startListening = async () => {
    if (!recognitionRef.current) {
      console.log('‚ùå Recognition non disponible');
      return;
    }

    try {
      if (isListening && isConversationActive) {
        console.log('üõë Arr√™t de la conversation en cours...');
        stopSpeaking();
        cleanupMicrophone();
        return;
      }

      console.log('üöÄ D√©marrage nouvelle conversation');
      isStoppedRef.current = false;
      setIsConversationActive(true);

      if (isSpeaking) {
        stopSpeaking();
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaStreamRef.current = stream;

      recognitionRef.current.start();
      setIsListening(true);
      
      console.log('üé§ Conversation continue d√©marr√©e');
    } catch (error) {
      console.error('‚ùå Erreur d√©marrage conversation:', error);
      cleanupMicrophone();
    }
  };

  const stopListening = () => {
    console.log('üõë Arr√™t complet de la conversation');
    setIsConversationActive(false);
    stopSpeaking();
    cleanupMicrophone();
  };

  // Configuration de la reconnaissance vocale
  useEffect(() => {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognitionClass = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognitionClass();
      
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;
      recognitionRef.current.lang = 'fr-FR';

      recognitionRef.current.onresult = (event) => {
        let finalTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            finalTranscript += event.results[i][0].transcript;
          }
        }
        
        if (finalTranscript.trim()) {
          console.log('üéØ Transcript final d√©tect√©:', finalTranscript);
          setTranscript(finalTranscript);
          
          // Nettoyer le timeout pr√©c√©dent
          if (responseTimeoutRef.current) {
            clearTimeout(responseTimeoutRef.current);
          }
          
          // D√©lai pour √©viter les coupures pr√©matur√©es
          responseTimeoutRef.current = setTimeout(() => {
            if (!isStoppedRef.current && isConversationActive) {
              console.log('‚ö° Traitement du transcript apr√®s d√©lai');
              processAIResponse(finalTranscript);
            }
          }, 1500);
        }
      };

      recognitionRef.current.onerror = (event) => {
        console.error('‚ùå Erreur reconnaissance:', event.error);
        
        // Gestion intelligente des erreurs
        if (event.error === 'no-speech' && isConversationActive && !isStoppedRef.current) {
          console.log('üîÑ Red√©marrage apr√®s silence...');
          setTimeout(() => {
            if (isConversationActive && !isStoppedRef.current && !isListening) {
              restartListening();
            }
          }, 1000);
        } else if (event.error !== 'aborted' && isConversationActive && !isStoppedRef.current) {
          console.log('üîÑ Red√©marrage apr√®s erreur...');
          setTimeout(() => {
            if (isConversationActive && !isStoppedRef.current && !isListening) {
              restartListening();
            }
          }, 2000);
        }
      };

      recognitionRef.current.onend = () => {
        console.log('üèÅ Reconnaissance termin√©e - Active:', isConversationActive, 'Stopped:', isStoppedRef.current);
        setIsListening(false);
        
        // Red√©marrage automatique si conversation active
        if (isConversationActive && !isStoppedRef.current && !isSpeaking && !isProcessing) {
          console.log('üîÑ Auto-red√©marrage apr√®s fin normale');
          setTimeout(() => {
            if (isConversationActive && !isStoppedRef.current && !isListening) {
              restartListening();
            }
          }, 500);
        }
      };
    } else {
      console.error('‚ùå Reconnaissance vocale non support√©e');
    }

    return () => {
      cleanupMicrophone();
      stopSpeaking();
    };
  }, [onTranscript, conversationMode, chatGPT]);

  return {
    isListening,
    transcript,
    isProcessing,
    lastResponse,
    isSpeaking,
    isConversationActive,
    startListening,
    stopListening,
    stopSpeaking,
    cleanupMicrophone
  };
};
