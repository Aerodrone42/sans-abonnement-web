
import { ClientInfo } from '../types/clientInfo';

export class ClientInfoExtractor {
  static extractClientInfo(
    message: string, 
    clientInfo: ClientInfo, 
    fillFormCallback: ((data: any) => void) | null
  ): ClientInfo {
    console.log('üîç D√âBUT EXTRACTION - Message:', message);
    console.log('üîç Callback disponible:', !!fillFormCallback);
    console.log('üîç ClientInfo actuel:', clientInfo);
    
    const lowerMessage = message.toLowerCase();
    const updatedInfo = { ...clientInfo };
    
    // Donn√©es pour le remplissage automatique du formulaire
    let formDataToFill: any = {};
    let hasNewInfo = false;

    // EXTRACTION DU NOM - VERSION AM√âLIOR√âE
    if (!updatedInfo.nom) {
      console.log('üîç Tentative extraction NOM');
      
      let extractedName = '';
      
      // Patterns √©tendus pour le nom
      const namePatterns = [
        /(?:je m'appelle|mon nom est|c'est|je suis|nom[:\s]+|pr√©nom[:\s]+)\s*([a-zA-Z√Ä-√ø\s-]{2,40})/i,
        /^([A-Z√Ä-≈∏][a-zA-Z√Ä-√ø-]{1,20}(?:\s+[A-Z√Ä-≈∏][a-zA-Z√Ä-√ø-]{1,20}){0,3})/,
        /bonjour\s+(?:je suis\s+)?([a-zA-Z√Ä-√ø\s-]{2,30})/i,
        /salut\s+(?:c'est\s+)?([a-zA-Z√Ä-√ø\s-]{2,30})/i
      ];
      
      for (const pattern of namePatterns) {
        const match = message.match(pattern);
        if (match) {
          extractedName = match[1].trim();
          // Nettoyer le nom extrait
          extractedName = extractedName.replace(/[.,!?]/g, '').trim();
          if (extractedName.length > 1 && !extractedName.match(/\b(bonjour|salut|merci|oui|non|ok)\b/i)) {
            break;
          } else {
            extractedName = '';
          }
        }
      }
      
      // Si toujours pas trouv√©, essayer de d√©tecter un nom en d√©but de message
      if (!extractedName && message.trim().length > 0) {
        const words = message.trim().split(/\s+/);
        const firstWord = words[0];
        
        // V√©rifier si le premier mot ressemble √† un pr√©nom
        if (firstWord.match(/^[A-Z√Ä-≈∏][a-zA-Z√Ä-√ø-]{1,20}$/) && 
            !firstWord.match(/\b(Bonjour|Salut|Merci|Oui|Non|Ok|Je|Il|Elle|Mon|Ma|Le|La|Un|Une)\b/i)) {
          
          // Prendre le premier et √©ventuellement le deuxi√®me mot
          if (words.length > 1 && words[1].match(/^[A-Z√Ä-≈∏][a-zA-Z√Ä-√ø-]{1,20}$/)) {
            extractedName = `${firstWord} ${words[1]}`;
          } else {
            extractedName = firstWord;
          }
        }
      }
      
      if (extractedName && extractedName.length > 1) {
        updatedInfo.nom = extractedName;
        formDataToFill.nom = extractedName; // Utiliser 'nom' au lieu de 'name'
        hasNewInfo = true;
        console.log('‚úÖ NOM EXTRAIT:', extractedName);
      }
    }

    // EXTRACTION EMAIL - VERSION AM√âLIOR√âE
    if (!updatedInfo.email) {
      console.log('üîç Tentative extraction EMAIL');
      
      // Email standard
      const emailMatch = message.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i);
      if (emailMatch) {
        updatedInfo.email = emailMatch[1].toLowerCase();
        formDataToFill.email = emailMatch[1].toLowerCase();
        hasNewInfo = true;
        console.log('‚úÖ EMAIL EXTRAIT:', emailMatch[1]);
      } else {
        // Patterns pour email dict√© ou mal format√©
        const emailPatterns = [
          /([a-zA-Z0-9._%+-]+)\s*(?:arobase|@|at)\s*([a-zA-Z0-9.-]+)\s*(?:point|\.)\s*([a-zA-Z]{2,})/i,
          /email[:\s]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i,
          /mail[:\s]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/i
        ];
        
        for (const pattern of emailPatterns) {
          const match = message.match(pattern);
          if (match) {
            let email;
            if (match.length > 3) {
              // Email reconstruit depuis arobase/point
              email = `${match[1]}@${match[2]}.${match[3]}`.replace(/\s+/g, '');
            } else {
              email = match[1];
            }
            updatedInfo.email = email.toLowerCase();
            formDataToFill.email = email.toLowerCase();
            hasNewInfo = true;
            console.log('‚úÖ EMAIL RECONSTRUIT:', email);
            break;
          }
        }
      }
    }

    // EXTRACTION T√âL√âPHONE - VERSION AM√âLIOR√âE
    if (!updatedInfo.telephone) {
      console.log('üîç Tentative extraction T√âL√âPHONE');
      
      const phonePatterns = [
        // T√©l√©phone fran√ßais standard
        /(\+33|0)\s*[1-9](?:[\s.-]?\d){8}/g,
        // Format avec espaces/tirets
        /([0-9]{2}[\s.-]?[0-9]{2}[\s.-]?[0-9]{2}[\s.-]?[0-9]{2}[\s.-]?[0-9]{2})/g,
        // T√©l√©phone avec mots-cl√©s
        /(?:t√©l√©phone|tel|phone|portable)[:\s]*([0-9\s.-]{10,})/i,
        // Num√©ro dict√©
        /([0-9]+[\s.-]*[0-9]+[\s.-]*[0-9]+[\s.-]*[0-9]+[\s.-]*[0-9]+)/g
      ];
      
      for (const pattern of phonePatterns) {
        const phoneMatch = message.match(pattern);
        if (phoneMatch) {
          const cleanPhone = phoneMatch[phoneMatch.length > 1 ? phoneMatch.length - 1 : 0]
            .replace(/[\s.-]/g, '');
          
          if (cleanPhone.length >= 10 && cleanPhone.match(/^[0-9+]+$/)) {
            updatedInfo.telephone = cleanPhone;
            formDataToFill.telephone = cleanPhone;
            hasNewInfo = true;
            console.log('‚úÖ T√âL√âPHONE EXTRAIT:', cleanPhone);
            break;
          }
        }
      }
    }

    // EXTRACTION ENTREPRISE - VERSION CONSID√âRABLEMENT AM√âLIOR√âE
    if (!updatedInfo.entreprise) {
      console.log('üîç Tentative extraction ENTREPRISE');
      
      let extractedBusiness = '';
      
      const businessPatterns = [
        // Patterns explicites
        /(?:ma soci√©t√©|mon entreprise|la soci√©t√©|l'entreprise|je travaille chez|chez|soci√©t√©[:\s]+|entreprise[:\s]+)\s+([a-zA-Z√Ä-√ø\s&.'-]{2,50})/i,
        // Patterns avec secteur
        /(?:dans le|secteur|domaine)[:\s]+([a-zA-Z√Ä-√ø\s&.'-]{3,40})/i,
        // Patterns business
        /(?:business|company|firm)[:\s]+([a-zA-Z√Ä-√ø\s&.'-]{2,50})/i,
        // Pattern pour SARL, SAS, etc.
        /([a-zA-Z√Ä-√ø\s&.'-]{2,30})\s+(?:SARL|SAS|SA|EURL|SNC|SASU)/i,
      ];
      
      for (const pattern of businessPatterns) {
        const match = message.match(pattern);
        if (match) {
          extractedBusiness = match[1].trim();
          // Nettoyer le nom d'entreprise
          extractedBusiness = extractedBusiness.replace(/[.,!?]$/, '').trim();
          if (extractedBusiness.length > 2) {
            break;
          } else {
            extractedBusiness = '';
          }
        }
      }
      
      // D√©tection de secteurs d'activit√© courants
      if (!extractedBusiness) {
        const secteurs = {
          'artisan': ['artisan', 'plombier', '√©lectricien', 'ma√ßon', 'menuisier', 'peintre', 'chauffagiste', 'couvreur'],
          'restauration': ['restaurant', 'caf√©', 'bar', 'boulangerie', 'p√¢tisserie', 'traiteur'],
          'beaut√©': ['coiffeur', 'esth√©tique', 'massage', 'spa', 'onglerie'],
          'commerce': ['commerce', 'magasin', 'boutique', 'vente', 'retail'],
          'services': ['conseil', 'consulting', 'formation', 'coaching'],
          'sant√©': ['m√©decin', 'dentiste', 'pharmacie', 'kin√©', 'ost√©opathe'],
          'tech': ['informatique', 'd√©veloppement', 'web', 'digital', 'tech']
        };
        
        for (const [secteur, mots] of Object.entries(secteurs)) {
          if (mots.some(mot => lowerMessage.includes(mot))) {
            extractedBusiness = secteur.charAt(0).toUpperCase() + secteur.slice(1);
            break;
          }
        }
      }
      
      if (extractedBusiness && extractedBusiness.length > 2) {
        updatedInfo.entreprise = extractedBusiness;
        formDataToFill.entreprise = extractedBusiness;
        hasNewInfo = true;
        console.log('‚úÖ ENTREPRISE EXTRAITE:', extractedBusiness);
      }
    }

    // REMPLISSAGE AUTOMATIQUE DU FORMULAIRE - VERSION AM√âLIOR√âE
    console.log('üéØ Nouvelles donn√©es d√©tect√©es:', hasNewInfo);
    console.log('üéØ Donn√©es √† remplir:', formDataToFill);
    
    if (hasNewInfo && fillFormCallback) {
      console.log('üöÄ REMPLISSAGE AUTOMATIQUE DU FORMULAIRE !');
      try {
        // Mapper les champs selon les noms attendus par le formulaire
        const mappedData = {
          // Essayer diff√©rents noms de champs possibles
          ...(formDataToFill.nom && { 
            name: formDataToFill.nom,
            nom: formDataToFill.nom,
            fullName: formDataToFill.nom,
            'nom-prenom': formDataToFill.nom
          }),
          ...(formDataToFill.email && { 
            email: formDataToFill.email,
            'email-professionnel': formDataToFill.email,
            mail: formDataToFill.email
          }),
          ...(formDataToFill.telephone && { 
            phone: formDataToFill.telephone,
            telephone: formDataToFill.telephone,
            tel: formDataToFill.telephone
          }),
          ...(formDataToFill.entreprise && { 
            company: formDataToFill.entreprise,
            entreprise: formDataToFill.entreprise,
            business: formDataToFill.entreprise,
            'entreprise-secteur': formDataToFill.entreprise
          })
        };
        
        fillFormCallback(mappedData);
        console.log('‚úÖ Formulaire rempli automatiquement avec:', mappedData);
      } catch (error) {
        console.error('‚ùå Erreur remplissage formulaire:', error);
      }
    } else if (hasNewInfo && !fillFormCallback) {
      console.error('‚ùå NOUVELLES INFOS D√âTECT√âES MAIS PAS DE CALLBACK !');
    } else {
      console.log('‚ÑπÔ∏è Aucune nouvelle information d√©tect√©e');
    }

    // Extraire le m√©tier SEULEMENT si on est dans la phase d'accueil
    if (updatedInfo.conversationStage === 'accueil' && !updatedInfo.metier) {
      if (lowerMessage.includes('artisan') || lowerMessage.includes('plombier') || lowerMessage.includes('√©lectricien') || lowerMessage.includes('ma√ßon') || lowerMessage.includes('menuisier') || lowerMessage.includes('peintre') || lowerMessage.includes('chauffagiste') || lowerMessage.includes('couvreur')) {
        updatedInfo.metier = 'Artisan du b√¢timent';
      } else if (lowerMessage.includes('restaurant') || lowerMessage.includes('caf√©') || lowerMessage.includes('bar') || lowerMessage.includes('boulangerie') || lowerMessage.includes('p√¢tisserie')) {
        updatedInfo.metier = 'Restauration/Alimentation';
      } else if (lowerMessage.includes('coiffeur') || lowerMessage.includes('esth√©tique') || lowerMessage.includes('massage') || lowerMessage.includes('spa')) {
        updatedInfo.metier = 'Beaut√©/Bien-√™tre';
      } else if (lowerMessage.includes('commerce') || lowerMessage.includes('magasin') || lowerMessage.includes('boutique') || lowerMessage.includes('vente')) {
        updatedInfo.metier = 'Commerce/Retail';
      } else if (message.trim().length > 0 && !lowerMessage.includes('bonjour') && !lowerMessage.includes('informations')) {
        updatedInfo.metier = message.trim();
      }
    }
    
    if (updatedInfo.conversationStage === 'proposition_contact') {
      if (lowerMessage.includes('formulaire') || lowerMessage.includes('email') || lowerMessage.includes('√©crit') || lowerMessage.includes('devis')) {
        updatedInfo.choixContact = 'formulaire';
        updatedInfo.conversationStage = 'collecte_infos_formulaire';
        updatedInfo.formulaireEtape = 'nom';
        console.log('üìã Client a choisi le FORMULAIRE - d√©but collecte nom');
      } else if (lowerMessage.includes('appel') || lowerMessage.includes('t√©l√©phone') || lowerMessage.includes('rappel')) {
        updatedInfo.choixContact = 'appel';
        updatedInfo.conversationStage = 'collecte_infos_rappel';
        console.log('üìû Client a choisi l\'APPEL - d√©but collecte infos');
      }
    }

    console.log('üìã Infos client FINALES:', updatedInfo);
    return updatedInfo;
  }
}
